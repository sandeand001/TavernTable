diff --git a/src/core/ModelAssetCache.js b/src/core/ModelAssetCache.js
index 596e1d3..02550db 100644
--- a/src/core/ModelAssetCache.js
+++ b/src/core/ModelAssetCache.js
@@ -4,6 +4,7 @@ class ModelAssetCache {
     this._three = null;
     this._cache = new Map();
     this._loading = new Map();
+    this._fbxLoaderCtorPromise = null;
     const base = 'assets/terrain/3d Assets/OBJ';
     this._registry = {
       'common-broadleaf-1': [`${base}/CommonTree_1.obj`],
@@ -33,91 +34,46 @@ class ModelAssetCache {
       'tree-oak-3': [`${base}/CommonTree_3.obj`],
       'tree-birch-1': [`${base}/CommonTree_4.obj`],
       'tree-birch-2': [`${base}/CommonTree_5.obj`],
-      'tree-birch-3': [`${base}/TwistedTree_1.obj`],
-      'tree-bare-deciduous-a': [`${base}/TwistedTree_1.obj`],
-      'tree-pine-1': [`${base}/Pine_1.obj`],
-      'tree-pine-2': [`${base}/Pine_2.obj`],
-      'tree-pine-3': [`${base}/Pine_3.obj`],
-      'tree-fir-1': [`${base}/Pine_4.obj`],
-      'tree-fir-2': [`${base}/Pine_5.obj`],
-      'tree-fir-3': [`${base}/TwistedTree_2.obj`],
-      'fern-1': [`${base}/Clover_1.obj`],
-      'fern-2': [`${base}/Clover_2.obj`],
-      'fern-3': [`${base}/Fern_1.obj`],
-      'rock-1': [`${base}/Rock_Medium_1.obj`],
-      'rock-2': [`${base}/Rock_Medium_2.obj`],
-      'rock-3': [`${base}/Rock_Medium_3.obj`],
-      // expanded families
-      'birch-1': [`${base}/Birch_1.obj`],
-      'birch-2': [`${base}/Birch_2.obj`],
-      'birch-3': [`${base}/Birch_3.obj`],
-      'birch-4': [`${base}/Birch_4.obj`],
-      'birch-5': [`${base}/Birch_5.obj`],
-      'cherry-1': [`${base}/CherryBlossom_1.obj`],
-      'cherry-2': [`${base}/CherryBlossom_2.obj`],
-      'cherry-3': [`${base}/CherryBlossom_3.obj`],
-      'cherry-4': [`${base}/CherryBlossom_4.obj`],
-      'cherry-5': [`${base}/CherryBlossom_5.obj`],
-      'giant-pine-1': [`${base}/GiantPine_1.obj`],
-      'giant-pine-2': [`${base}/GiantPine_2.obj`],
-      'giant-pine-3': [`${base}/GiantPine_3.obj`],
-      'giant-pine-4': [`${base}/GiantPine_4.obj`],
-      'giant-pine-5': [`${base}/GiantPine_5.obj`],
-      'dead-tree-1': [`${base}/DeadTree_1.obj`],
-      'dead-tree-2': [`${base}/DeadTree_2.obj`],
-      'dead-tree-3': [`${base}/DeadTree_3.obj`],
-      'dead-tree-4': [`${base}/DeadTree_4.obj`],
-      'dead-tree-5': [`${base}/DeadTree_5.obj`],
-      'ground-cover-fern-2': [`${base}/Fern_2.obj`],
-      'tall-thick-1': [`${base}/TallThick_1.obj`],
-      'tall-thick-2': [`${base}/TallThick_2.obj`],
-      'tall-thick-3': [`${base}/TallThick_3.obj`],
-      'tall-thick-4': [`${base}/TallThick_4.obj`],
-      'tall-thick-5': [`${base}/TallThick_5.obj`],
-      'bush-common': [`${base}/Bush_Common.obj`],
-      'bush-common-flowers': [`${base}/Bush_Common_Flowers.obj`],
-      'bush-large': [`${base}/Bush_Large.obj`],
-      'bush-large-flowers': [`${base}/Bush_Large_Flowers.obj`],
-      'bush-long-1': [`${base}/Bush_Long_1.obj`],
-      'bush-long-2': [`${base}/Bush_Long_2.obj`],
-      'flower-1-group': [`${base}/Flower_1_Group.obj`],
-      'flower-1-single': [`${base}/Flower_1_Single.obj`],
-      'flower-2-group': [`${base}/Flower_2_Group.obj`],
-      'flower-2-single': [`${base}/Flower_2_Single.obj`],
-      'flower-3-group': [`${base}/Flower_3_Group.obj`],
-      'flower-3-single': [`${base}/Flower_3_Single.obj`],
-      'flower-4-group': [`${base}/Flower_4_Group.obj`],
-      'flower-4-single': [`${base}/Flower_4_Single.obj`],
-      'flower-6': [`${base}/Flower_6.obj`],
-      'flower-6-2': [`${base}/Flower_6_2.obj`],
-      'flower-7-group': [`${base}/Flower_7_Group.obj`],
-      'flower-7-single': [`${base}/Flower_7_Single.obj`],
-      'mushroom-common': [`${base}/Mushroom_Common.obj`],
-      'mushroom-redcap': [`${base}/Mushroom_RedCap.obj`],
-      'mushroom-oyster': [`${base}/Mushroom_Oyster.obj`],
-      'mushroom-laetiporus': [`${base}/Mushroom_Laetiporus.obj`],
-      'grass-common-short': [`${base}/Grass_Common_Short.obj`],
-      'grass-common-tall': [`${base}/Grass_Common_Tall.obj`],
-      'grass-wide-short': [`${base}/Grass_Wide_Short.obj`],
-      'grass-wide-tall': [`${base}/Grass_Wide_Tall.obj`],
-      'grass-wispy-short': [`${base}/Grass_Wispy_Short.obj`],
-      'grass-wispy-tall': [`${base}/Grass_Wispy_Tall.obj`],
-      'grass-wheat': [`${base}/Grass_Wheat.obj`],
-      'rock-medium-4': [`${base}/Rock_Medium_4.obj`],
-      'rock-big-1': [`${base}/Rock_Big_1.obj`],
-      'rock-big-2': [`${base}/Rock_Big_2.obj`],
-      'pebble-round-1': [`${base}/Pebble_Round_1.obj`],
-      'pebble-round-2': [`${base}/Pebble_Round_2.obj`],
-      'pebble-round-3': [`${base}/Pebble_Round_3.obj`],
-      'pebble-round-4': [`${base}/Pebble_Round_4.obj`],
-      'pebble-round-5': [`${base}/Pebble_Round_5.obj`],
-      'pebble-square-1': [`${base}/Pebble_Square_1.obj`],
-      'pebble-square-2': [`${base}/Pebble_Square_2.obj`],
-      'pebble-square-3': [`${base}/Pebble_Square_3.obj`],
-      'pebble-square-4': [`${base}/Pebble_Square_4.obj`],
-      'pebble-square-5': [`${base}/Pebble_Square_5.obj`],
-      'pebble-square-6': [`${base}/Pebble_Square_6.obj`],
-    };
+        {
+          baseColor: 'T_MZRa_Monstera_B07b_BC.png',
+          normal: 'T_MZRa_Monstera_B07b_N.png',
+          roughness: 'T_MZRa_Monstera_B07b_R.png',
+        },
+        {
+          foliageAlphaTest: 0.26,
+        }
+      ),
+      'tropical-fern-a': makeTropicalEntry(
+        'Fern_B051',
+        {
+          baseColor: 'T_MZRa_Fern_B051_BC.png',
+          opacity: 'T_MZRa_Fern_B051_O.png',
+        },
+        {
+          foliageAlphaTest: 0.34,
+        }
+      ),
+      'tropical-fern-b': makeTropicalEntry(
+        'Fern_B052',
+        {
+          baseColor: 'T_MZRa_Fern_B052_BC.png',
+          opacity: 'T_MZRa_Fern_B052_O.png',
+        },
+        {
+          foliageAlphaTest: 0.34,
+        }
+      ),
+      'tropical-fern-c': makeTropicalEntry(
+        'Fern_B053',
+        {
+          baseColor: 'T_MZRa_Fern_B053_BC.png',
+          opacity: 'T_MZRa_Fern_B053_O.png',
+        },
+        {
+          foliageAlphaTest: 0.34,
+        }
+      ),
+    });
     this._legacyToCanonical = {
       'tree-oak-1': 'common-broadleaf-1',
       'tree-oak-2': 'common-broadleaf-2',
@@ -139,6 +95,10 @@ class ModelAssetCache {
       'rock-2': 'rock-medium-2',
       'rock-3': 'rock-medium-3',
     };
+    Object.assign(this._legacyToCanonical, {
+      'palm-single-a': 'tropical-palm-a',
+      'palm-double-a': 'tropical-palm-b',
+    });
   }
 
   setThree(three) {
@@ -164,14 +124,43 @@ class ModelAssetCache {
     }
   }
 
+  async _loadRegistryEntry(three, key, entry) {
+    if (!entry) return null;
+    if (typeof entry === 'string') return this._loadOBJ(three, key, entry);
+    const path = entry.path;
+    if (!path) return null;
+    const fmt = String(entry.format || path.split('.').pop() || '').toLowerCase();
+    if (fmt === 'fbx') return this._loadFBX(three, key, entry);
+    return this._loadOBJ(three, key, path, entry);
+  }
+
+  _buildPathVariants(path) {
+    const normalized = String(path || '').replace(/\\/g, '/');
+    const variants = [];
+    const push = (value) => {
+      if (!value || variants.includes(value)) return;
+      variants.push(value);
+    };
+    push(normalized);
+    if (!normalized.startsWith('./')) push(`./${normalized}`);
+    if (!normalized.startsWith('/')) push(`/${normalized}`);
+    if (normalized.includes(' ')) push(normalized.replace(/ /g, '%20'));
+    variants.slice().forEach((v) => {
+      if (v.includes('3d Assets')) push(v.replace('3d Assets', '3d%20Assets'));
+      if (v.includes(' ')) push(v.replace(/ /g, '%20'));
+    });
+    return variants;
+  }
+
   async getModel(key) {
     key = this._resolveKey(key);
     if (this._cache.has(key)) return this._cache.get(key).clone(true);
     if (this._loading.has(key)) return (await this._loading.get(key)).clone(true);
-    const paths = this._registry[key];
-    if (!paths || !paths.length) return null;
+    const rawEntry = this._registry[key];
+    const entry = Array.isArray(rawEntry) ? rawEntry[0] : rawEntry;
+    if (!entry) return null;
     if (!this._three) await this._ensureThreeAndLoader();
-    const promise = this._loadOBJ(this._three, key, paths[0]);
+    const promise = this._loadRegistryEntry(this._three, key, entry);
     this._loading.set(key, promise);
     const obj = await promise;
     this._loading.delete(key);
@@ -179,13 +168,13 @@ class ModelAssetCache {
     else if (typeof console !== 'undefined') {
       console.warn('[ModelAssetCache] Failed to load', {
         key,
-        path: paths[0],
+        path: typeof entry === 'string' ? entry : entry?.path,
       });
     }
     return obj ? obj.clone(true) : null;
   }
 
-  async _loadOBJ(three, key, path) {
+  async _loadOBJ(three, key, path, entry) {
     if (!three) return null;
     let OBJLoaderMod = null;
     const VERBOSE = !!(typeof window !== 'undefined' && window.DEBUG_MODEL_CACHE_VERBOSE);
@@ -210,17 +199,7 @@ class ModelAssetCache {
     const OBJLoader = OBJLoaderMod.OBJLoader || OBJLoaderMod.default;
     if (!OBJLoader) return null;
     const attempted = new Set();
-    const buildVariants = (p) => {
-      const out = [p];
-      if (p.includes('3d Assets')) out.push(p.replace('3d Assets', '3d%20Assets'));
-      if (!p.startsWith('./')) out.push('./' + p);
-      if (!p.startsWith('/')) out.push('/' + p);
-      out.slice().forEach((v) => {
-        if (v.includes('3d Assets')) out.push(v.replace('3d Assets', '3d%20Assets'));
-      });
-      return [...new Set(out)];
-    };
-    const variants = buildVariants(path);
+    const variants = this._buildPathVariants(path);
     const tryLoad = (i) =>
       new Promise((resolve) => {
         if (i >= variants.length) return resolve(null);
@@ -243,7 +222,7 @@ class ModelAssetCache {
             url,
             (root) => {
               try {
-                this._postProcess(three, root, key, url, 'OBJ');
+                this._postProcess(three, root, key, url, 'OBJ', entry);
               } catch (postErr) {
                 // ignore post-process error for individual variant
               }
@@ -274,18 +253,275 @@ class ModelAssetCache {
     return result;
   }
 
-  _postProcess(three, root, key, path, kind) {
+  async _ensureFBXLoaderCtor() {
+    if (this._fbxLoaderCtorPromise) return this._fbxLoaderCtorPromise;
+    this._fbxLoaderCtorPromise = (async () => {
+      try {
+        const mod = await import('three/examples/jsm/loaders/FBXLoader.js');
+        return mod.FBXLoader || mod.default || null;
+      } catch (err) {
+        try {
+          const fallback = await import(
+            'https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/loaders/FBXLoader.js'
+          );
+          if (typeof console !== 'undefined') {
+            console.info('[ModelAssetCache] FBXLoader CDN fallback');
+          }
+          return fallback.FBXLoader || fallback.default || null;
+        } catch (err2) {
+          if (typeof console !== 'undefined') {
+            console.error('[ModelAssetCache] FBXLoader import failed', err, err2);
+          }
+          return null;
+        }
+      }
+    })();
+    return this._fbxLoaderCtorPromise;
+  }
+
+  async _loadFBX(three, key, entry) {
+    if (!three || !entry?.path) return null;
+    const FBXLoaderCtor = await this._ensureFBXLoaderCtor();
+    if (!FBXLoaderCtor) return null;
+    const variants = this._buildPathVariants(entry.path);
+    const attempted = new Set();
+    const VERBOSE = !!(typeof window !== 'undefined' && window.DEBUG_MODEL_CACHE_VERBOSE);
+    const tryLoad = (index) =>
+      new Promise((resolve) => {
+        if (index >= variants.length) return resolve(null);
+        const url = variants[index];
+        attempted.add(url);
+        let loader;
+        try {
+          loader = new FBXLoaderCtor();
+        } catch {
+          return resolve(null);
+        }
+        try {
+          if (loader.setResourcePath) {
+            const resource = entry.resourcePath || url.split('/').slice(0, -1).join('/');
+            const normalizedResource = resource.endsWith('/') ? resource : `${resource}/`;
+            loader.setResourcePath(normalizedResource);
+          }
+        } catch (_) {
+          /* ignore resource path issues */
+        }
+        let settled = false;
+        const finish = (obj) => {
+          if (settled) return;
+          settled = true;
+          resolve(obj);
+        };
+        try {
+          loader.load(
+            url,
+            (root) => {
+              let result = root;
+              try {
+                result = this._selectFBXNode(three, root, entry, key);
+              } catch (_) {
+                result = root;
+              }
+              try {
+                this._pruneFBXArtifacts(result, entry);
+              } catch (_) {
+                /* pruning optional */
+              }
+              if (entry?.textureBase) {
+                try {
+                  if (!result.userData) result.userData = {};
+                  result.userData.__textureBase = entry.textureBase;
+                } catch (_) {
+                  /* ignore */
+                }
+              }
+              try {
+                this._postProcess(three, result, key, url, 'FBX', entry);
+              } catch (_) {
+                /* best effort */
+              }
+              if (entry?.centerAndGround) {
+                try {
+                  this._centerAndGround(three, result, entry.centerAndGround);
+                } catch (_) {
+                  /* optional */
+                }
+              }
+              if (VERBOSE && typeof console !== 'undefined' && url !== entry.path)
+                console.info('[ModelAssetCache] FBX fallback path', { key, url });
+              finish(result);
+            },
+            undefined,
+            () => {
+              tryLoad(index + 1).then(finish);
+            }
+          );
+        } catch (loadErr) {
+          tryLoad(index + 1).then(finish);
+        }
+      });
+    const result = await tryLoad(0);
+    if (!result && typeof console !== 'undefined') {
+      console.error('[ModelAssetCache] All FBX load variants failed', {
+        key,
+        variants: [...attempted],
+      });
+    }
+    return result;
+  }
+
+  _selectFBXNode(three, root, entry, key) {
+    if (!entry?.node || !root) return root;
+    const target = String(entry.node || '').toLowerCase();
+    const matches = [];
     try {
+      root.traverse?.((child) => {
+        const name = String(child?.name || '').toLowerCase();
+        if (!name) return;
+        if (name === target || name.startsWith(`${target}_`) || name.includes(target)) {
+          matches.push(child);
+        }
+      });
+    } catch (_) {
+      /* ignore traversal failure */
+    }
+    if (!matches.length) return root;
+    const topLevel = matches.filter((node) => {
+      let parent = node.parent;
+      while (parent) {
+        if (matches.includes(parent)) return false;
+        parent = parent.parent;
+      }
+      return true;
+    });
+    const group = new three.Group();
+    group.name = `FBX:${key}:${entry.node}`;
+    const attached = new Set();
+    topLevel.forEach((node) => {
+      if (!node) return;
+      const clone = node.clone(true);
+      if (!clone) return;
+      if (attached.has(clone.uuid)) return;
+      attached.add(clone.uuid);
+      group.add(clone);
+    });
+    return group.children.length ? group : root;
+  }
+
+  _pruneFBXArtifacts(root, entry) {
+    if (!root) return;
+    const patterns = [];
+    if (Array.isArray(entry?.prune)) {
+      entry.prune.forEach((pat) => {
+        if (pat instanceof RegExp) patterns.push(pat);
+        else if (typeof pat === 'string' && pat.trim())
+          patterns.push(new RegExp(pat.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i'));
+      });
+    }
+    if (!patterns.length) {
+      patterns.push(/\bbg\b/i, /background/i, /backdrop/i, /circle/i, /gradient/i, /plane/i);
+    }
+    const toRemove = [];
+    root.traverse?.((child) => {
+      if (!child || child === root) return;
+      const name = String(child.name || '');
+      if (!name) return;
+      const lower = name.toLowerCase();
+      const match = patterns.some((re) => re.test(lower));
+      if (!match) return;
+      if (child.parent) toRemove.push(child);
+    });
+    toRemove.forEach((node) => {
+      try {
+        node.parent?.remove(node);
+      } catch (_) {
+        /* ignore */
+      }
+    });
+  }
+
+  _centerAndGround(three, root, opts = {}) {
+    if (!three || !root) return;
+    try {
+      const box = new three.Box3().setFromObject(root);
+      if (!box || !Number.isFinite(box.min?.x) || !Number.isFinite(box.max?.y)) return;
+      const center = new three.Vector3();
+      box.getCenter(center);
+      const alignXZ = opts.alignXZ !== false;
+      const alignY = opts.alignY !== false;
+      const newPos = root.position.clone?.() || new three.Vector3();
+      if (alignXZ) {
+        newPos.x -= center.x;
+        newPos.z -= center.z;
+      }
+      if (alignY) newPos.y -= box.min.y;
+      root.position.copy(newPos);
+      root.updateMatrixWorld?.(true);
+    } catch (_) {
+      /* optional alignment */
+    }
+  }
+
+  _postProcess(three, root, key, path, kind, entry) {
+    try {
+      const textureBases = [];
+      if (entry?.textureBase) textureBases.push(entry.textureBase);
+      if (kind === 'FBX' && root && root.userData?.__textureBase) {
+        textureBases.push(root.userData.__textureBase);
+      }
+      if (textureBases.indexOf('assets/terrain/3d Assets/Textures') === -1) {
+        textureBases.push('assets/terrain/3d Assets/Textures');
+      }
+      const loadEntryTexture = (purpose) => {
+        const file = entry?.textures?.[purpose];
+        if (!file) return null;
+        return ensureTexture(file);
+      };
+      const ensureTexture = (file, extraBases) => {
+        if (!file) return null;
+        const bases = Array.isArray(extraBases) && extraBases.length ? extraBases : textureBases;
+        for (const base of bases) {
+          const full = `${base}/${file}`;
+          try {
+            if (!this._textureLoader) this._textureLoader = new three.TextureLoader();
+            if (!this._textureCache) this._textureCache = new Map();
+          } catch (_) {
+            continue;
+          }
+          let tex = this._textureCache.get(full);
+          if (!tex) {
+            try {
+              tex = this._textureLoader.load(full, () => {
+                if (tex && 'colorSpace' in tex && three.SRGBColorSpace) {
+                  tex.colorSpace = three.SRGBColorSpace;
+                  tex.needsUpdate = true;
+                }
+              });
+              this._textureCache.set(full, tex);
+            } catch (_) {
+              tex = null;
+            }
+          }
+          if (tex) return tex;
+        }
+        return null;
+      };
+      const keyLc = String(key || '').toLowerCase();
+      const isTallThick = /^tall-thick-/.test(keyLc);
       root.traverse((child) => {
         if (!child.isMesh) return;
         const mats = Array.isArray(child.material) ? child.material : [child.material];
         mats.forEach((mat) => {
           if (!mat) return;
           try {
-            if (!mat.map) {
+            const directBase = loadEntryTexture('baseColor');
+            if (directBase) {
+              mat.map = directBase;
+              mat.needsUpdate = true;
+              if (mat.map) mat.map.needsUpdate = true;
+            } else if (!mat.map) {
               if (!this._textureLoader) this._textureLoader = new three.TextureLoader();
               if (!this._textureCache) this._textureCache = new Map();
-              const texBase = 'assets/terrain/3d Assets/Textures';
               const nameLc = (mat.name || '').toLowerCase();
               const pick = () => {
                 if (/leaves_birch|birch_leaves/.test(nameLc)) return 'Leaves_Birch_C.png';
@@ -308,24 +544,25 @@ class ModelAssetCache {
               };
               const file = pick();
               if (file) {
-                const full = `${texBase}/${file}`;
-                let tex = this._textureCache.get(full);
-                if (!tex) {
-                  try {
-                    tex = this._textureLoader.load(full, () => {
-                      if (tex && 'colorSpace' in tex && three.SRGBColorSpace) {
-                        tex.colorSpace = three.SRGBColorSpace;
-                        tex.needsUpdate = true;
-                      }
-                    });
-                    this._textureCache.set(full, tex);
-                  } catch (textureErr) {
-                    // ignore individual texture load error
-                  }
-                }
+                const tex = ensureTexture(file);
                 if (tex) {
                   mat.map = tex;
                   mat.needsUpdate = true;
+                  if (mat.map) mat.map.needsUpdate = true;
+                  mat.opacity = 1;
+                  const hasOpacityMap = !!entry?.textures?.opacity;
+                  if (!hasOpacityMap) {
+                    mat.alphaMap = null;
+                    mat.transparent = false;
+                    mat.alphaTest = 0;
+                    mat.depthWrite = true;
+                  } else {
+                    mat.transparent = true;
+                    mat.depthWrite = false;
+                    if (entry?.foliageAlphaTest) {
+                      mat.alphaTest = Math.min(0.45, Math.max(0.05, entry.foliageAlphaTest));
+                    }
+                  }
                 }
               }
             }
@@ -335,20 +572,7 @@ class ModelAssetCache {
                 const src = mat.map.image?.src || mat.map.source?.data?.src || '';
                 if (/^[a-zA-Z]:\//.test(src)) {
                   const file = src.split(/[/\\]/).pop();
-                  const texBase = 'assets/terrain/3d Assets/Textures';
-                  const local = `${texBase}/${file}`;
-                  if (!this._textureLoader) this._textureLoader = new three.TextureLoader();
-                  if (!this._textureCache) this._textureCache = new Map();
-                  let tex = this._textureCache.get(local);
-                  if (!tex) {
-                    tex = this._textureLoader.load(local, () => {
-                      if (tex && 'colorSpace' in tex && three.SRGBColorSpace) {
-                        tex.colorSpace = three.SRGBColorSpace;
-                        tex.needsUpdate = true;
-                      }
-                    });
-                    this._textureCache.set(local, tex);
-                  }
+                  const tex = ensureTexture(file);
                   if (tex) {
                     mat.map = tex;
                     mat.needsUpdate = true;
@@ -359,34 +583,42 @@ class ModelAssetCache {
               } catch (_) {
                 /* ignore texture rewrite failures */
               }
-            }
-            const tag = (
-              (mat.name || '') +
+                  if (typeof mat.alphaTest !== 'number' || mat.alphaTest < 0.05) mat.alphaTest = hasOpacityMap ? 0.12 : 0;
+                  if (mat.alphaTest > 0.4) mat.alphaTest = 0.4;
               ' ' +
               (mat.map?.name || '') +
-              ' ' +
-              (mat.map?.image?.src || '')
-            ).toLowerCase();
             const isLeaf =
               /(leaf|leaves|foliage|canopy|crown|autumn|orange|yellow|red)/.test(tag) &&
               !/(bark|trunk|branch|rock|stone|ground|dirt)/.test(tag);
+            const isBark = /(bark|trunk|branch|wood)/.test(tag);
+            if (isTallThick) {
+              try {
+                if (isLeaf) {
+                  let foliageTex = ensureTexture('Leaves_NormalTree_C.png');
+                  if (!foliageTex) foliageTex = ensureTexture('Leaves_NormalTree.png');
+                  if (!foliageTex) foliageTex = ensureTexture('Leaves.png');
+                  if (foliageTex) {
+                    mat.map = foliageTex;
+                    mat.needsUpdate = true;
+                  }
+                } else if (isBark) {
+                  let barkTex = ensureTexture('Bark_NormalTree.png');
+                  if (!barkTex) barkTex = ensureTexture('Bark_PineTree.png');
+                  if (barkTex) {
+                    mat.map = barkTex;
+                    mat.needsUpdate = true;
+                  }
+                }
+              } catch (_) {
+                /* tall thick texture reassignment optional */
+              }
+            }
             if (!isLeaf) return;
             // If this is foliage and STILL no texture map was resolved, apply a generic leaf texture.
             if (!mat.map) {
               try {
                 if (!this._textureLoader) this._textureLoader = new three.TextureLoader();
-                const genericLeaf = 'assets/terrain/3d Assets/Textures/Leaves_NormalTree_C.png';
-                let tex = this._textureCache?.get?.(genericLeaf);
-                if (!tex) {
-                  if (!this._textureCache) this._textureCache = new Map();
-                  tex = this._textureLoader.load(genericLeaf, () => {
-                    if (tex && 'colorSpace' in tex && three.SRGBColorSpace) {
-                      tex.colorSpace = three.SRGBColorSpace;
-                      tex.needsUpdate = true;
-                    }
-                  });
-                  this._textureCache.set(genericLeaf, tex);
-                }
+                const tex = ensureTexture('Leaves_NormalTree_C.png');
                 if (tex) {
                   mat.map = tex;
                   mat.needsUpdate = true;
@@ -395,6 +627,62 @@ class ModelAssetCache {
                 /* ignore leaf fallback failure */
               }
             }
+            const setNormalMap = () => {
+              if (!entry?.textures?.normal) return;
+              const tex = ensureTexture(entry.textures.normal);
+              if (tex) {
+                mat.normalMap = tex;
+                mat.needsUpdate = true;
+                mat.normalMap.needsUpdate = true;
+              }
+            };
+            const setRoughnessMap = () => {
+              if (!entry?.textures?.roughness) return;
+              const tex = ensureTexture(entry.textures.roughness);
+              if (tex) {
+                mat.roughnessMap = tex;
+                mat.needsUpdate = true;
+                if (mat.roughnessMap?.needsUpdate !== undefined) {
+                  mat.roughnessMap.needsUpdate = true;
+                }
+              }
+            };
+            const setOpacityMap = () => {
+              if (!entry?.textures?.opacity) return;
+              const tex = ensureTexture(entry.textures.opacity);
+              if (tex) {
+                mat.alphaMap = tex;
+                mat.transparent = true;
+                mat.depthWrite = false;
+                mat.needsUpdate = true;
+                if (mat.alphaMap?.needsUpdate !== undefined) {
+                  mat.alphaMap.needsUpdate = true;
+                }
+              }
+            };
+            setNormalMap();
+            setRoughnessMap();
+            setOpacityMap();
+            if (mat.color) {
+              try {
+                if (mat.color.r < 0.2 && mat.color.g < 0.2 && mat.color.b < 0.2) {
+                  mat.color.setRGB(1, 1, 1);
+                  mat.needsUpdate = true;
+                }
+                if (!mat.map) {
+                  if (/trunk|stem|bark/.test(tag)) {
+                    mat.color.setHex(0x7a4e2b);
+                  } else if (/leaf|frond|foliage|palm|monstera|fern/.test(tag)) {
+                    mat.color.setHex(0x2f7f3e);
+                  } else {
+                    mat.color.setHex(0x7c7c7c);
+                  }
+                  mat.needsUpdate = true;
+                }
+              } catch (_) {
+                /* ignore color normalization failure */
+              }
+            }
             if (!mat.userData) mat.userData = {};
             mat.userData.__foliageCandidate = true;
             mat.transparent = true;
@@ -415,6 +703,9 @@ class ModelAssetCache {
             mat.depthWrite = false;
             mat.side = three.DoubleSide;
             mat.userData.__foliageStrategy = 'cutout-lite';
+            if (entry?.foliageAlphaTest) {
+              mat.alphaTest = Math.min(0.45, Math.max(0.05, entry.foliageAlphaTest));
+            }
             mat.needsUpdate = true;
           } catch (materialErr) {
             // ignore material processing error to keep model usable
@@ -454,9 +745,13 @@ class ModelAssetCache {
     // Large canopy & special tall forms
     if (/^giant-pine-/.test(key)) return 9.5; // towering giants
     if (/^tall-thick-/.test(key)) return 7.5; // massive thick trunks
+    if (/^tropical-palm-/.test(key)) return 6.4;
     // Standard mature trees (baseline)
     if (/^(common-broadleaf-|pine-conifer-|birch-|cherry-|dead-tree-|twisted-bare-)/.test(key))
       return 6.2;
+    if (/^tropical-banana-/.test(key)) return 3.6;
+    if (/^tropical-monstera-/.test(key)) return 2.4;
+    if (/^tropical-fern-/.test(key)) return 1.1;
     // Medium rocks slightly below tree canopy for variety
     if (/^rock-big-/.test(key)) return 4.2;
     if (/^rock-medium-/.test(key)) return 2.8;
